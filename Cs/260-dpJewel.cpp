// dp 要復習　9/20
// 問題：ある規則に従って、赤い宝石と蒼宝石から1つ低いレベルの宝石が生成される。最低レベルの青い宝石の数の最大値を求める。
// 教訓：係数nとn-1の関係がある数列 → 動的計画法
// 教訓：dp配列に入れるのは、最終的に欲しい答え。今回はレベルiの宝石から得られるレベル1の青い宝石の数。

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main () {
    int N,X,Y;
    cin >> N >> X >> Y;
    // R[i]→レベルiの赤い宝石から始めて最終的に得られるレベル1の青い宝石の数
    // B[i]→レベルiの青い宝石から始めて最終的に得られるレベル1の青い宝石の数
    vector<ll>R(N+1,0);
    vector<ll>B(N+1,0);
    R[1]=0;
    B[1]=1;

    for (int i=2; i<=N; i++) {
        B[i] = R[i-1]+B[i-1]*Y;
        R[i] = R[i-1]+B[i]*X;
    }

    cout << R[N] << endl;
}