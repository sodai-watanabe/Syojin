// 有向閉路 9/3 要復習 
// 教訓：有向閉路→有向頂点探索で訪問済みに到達
// 教訓：1頂点から1矢印なら2次元childは不要。1次元配列aでi→a[i]のイメージ。dfsも不要。
// 教訓：まず閉路を構成する頂点を求める。その頂点をスタート地点とすれば1周するだけでシンプル。何番目に訪問したかを管理する配列id[i]を用意。id[i]に値が入っていたら訪問済み。

#include <bits/stdc++.h>
using namespace std;


int main () {
    int N;
    cin >> N;

    vector<int>id(N+1,0); // 何手目に訪問したかを管理。
    vector<int>a(N+1,0);  // 有向グラフ管理。i→a[i]という関係。隣接リストに対応。

    for (int i=1; i<=N; i++) {
        cin >> a[i];
    }

    int k = 1;  // 何番目に訪問したか。最初は1番目なので。
    int v = 1;  // 探索する頂点。どこでもいいけど、とりあえず1から探索開始。

    // 頂点を隣接を辿って探索。
    // その都度「番目」を更新。未訪問である限り探索し続け、訪問済みに到達したらその頂点は閉路を構成している。
    // その頂点をvに格納。最後に出てきたvは確実に閉路内の頂点なので、次でvをスタートとして探索すると見通しが良い。
    while (id[v]==0) { 
        id[v]=k;
        k++;
        v = a[v];
    }

    set<int>st;     // 探索頂点を管理するset.
    vector<int>ans; // 閉路を構成する頂点をその順番に格納。

    // vから頂点を隣接を辿って探索。
    for (int i=0; i<N; i++) {
        if (st.count(v)) break; // 既に訪問済みなら打ち切り。
        st.insert(v);           // 未訪問ならsetに追加して訪問済みにする。

        ans.push_back(v);       // 今探索している頂点は必ず閉路を構成している。vが閉路内なので、その隣接も閉路内。
        v = a[v];               // 探索頂点vをその隣接頂点a[v]に更新。
    }

    cout << ans.size() << endl;

    for (auto v : ans) {
        cout << v << ' ';       // ansは閉路構成頂点。
    }
}